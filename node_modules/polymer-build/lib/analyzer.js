/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
"use strict";
const hydrolysis_1 = require('hydrolysis');
const path = require('path');
const stream_1 = require('stream');
const url_1 = require('url');
const logging = require('plylog');
const streams_1 = require('./streams');
const path_transformers_1 = require('./path-transformers');
const get_dependencies_from_document_1 = require('./get-dependencies-from-document');
const minimatchAll = require('minimatch-all');
const logger = logging.getLogger('cli.build.analyzer');
class StreamAnalyzer extends stream_1.Transform {
    constructor(root, entrypoint, shell, fragments, sourceGlobs) {
        super({ objectMode: true });
        this._dependenciesStream = new stream_1.PassThrough({ objectMode: true });
        this._dependenciesProcessingStream = new streams_1.VinylReaderTransform();
        this.files = new Map();
        this.foundDependencies = new Set();
        this._dependencyAnalysis = {
            depsToFragments: new Map(),
            fragmentToDeps: new Map(),
            fragmentToFullDeps: new Map()
        };
        this.root = root;
        this.entrypoint = entrypoint;
        this.shell = shell;
        this.fragments = fragments;
        this.sourceGlobs = sourceGlobs;
        this.allFragments = [];
        // It's important that shell is first for document-ordering of imports
        if (shell) {
            this.allFragments.push(shell);
        }
        if (entrypoint && !shell && fragments.length === 0) {
            this.allFragments.push(entrypoint);
        }
        if (fragments) {
            this.allFragments = this.allFragments.concat(fragments);
        }
        this.resolver = new StreamResolver(this);
        this.loader = new hydrolysis_1.Loader();
        this.loader.addResolver(this.resolver);
        this.analyzer = new hydrolysis_1.Analyzer(false, this.loader);
        // Connect the dependencies stream that the analyzer pushes into to the
        // processing stream which loads each file and attaches the file contents.
        this._dependenciesStream.pipe(this._dependenciesProcessingStream);
        this.allFragmentsToAnalyze = new Set(this.allFragments);
        this.analyzeDependencies = new Promise((resolve, reject) => {
            this._resolveDependencyAnalysis = resolve;
        });
    }
    /**
     * The source dependency stream that Analyzer pushes discovered dependencies
     * into is connected to the post-processing stream. We want consumers to only
     * use the post-processed data so that all file objects have contents
     * loaded by default. This also makes Analyzer easier for us to test.
     */
    get dependencies() {
        return this._dependenciesProcessingStream;
    }
    _transform(file, encoding, callback) {
        let filePath = file.path;
        this.addFile(file);
        // If our resolver is waiting for this file, resolve its deferred loader
        if (this.resolver.hasDeferredFile(filePath)) {
            this.resolver.resolveDeferredFile(filePath, file);
        }
        // Propagate the file so that the stream can continue
        callback(null, file);
        // If the file is a fragment, begin analysis on its dependencies
        if (this.isFragment(file)) {
            this._getDependencies(path_transformers_1.urlFromPath(this.root, filePath))
                .then((deps) => {
                // Add all found dependencies to our index
                this._addDependencies(filePath, deps);
                this.allFragmentsToAnalyze.delete(filePath);
                // If there are no more fragments to analyze, close the dependency stream
                if (this.allFragmentsToAnalyze.size === 0) {
                    this._dependenciesStream.end();
                }
            });
        }
    }
    _flush(done) {
        // If stream finished with files that still needed to be loaded, error out
        if (this.resolver.hasDeferredFiles()) {
            for (let fileUrl of this.resolver.deferredFiles.keys()) {
                logger.error(`${fileUrl} never loaded`);
            }
            done(new Error(`${this.resolver.deferredFiles.size} deferred files were never loaded`));
            return;
        }
        // Resolve our dependency analysis promise now that we have seen all files
        this._resolveDependencyAnalysis(this._dependencyAnalysis);
        done();
    }
    getFile(filepath) {
        let url = path_transformers_1.urlFromPath(this.root, filepath);
        return this.getFileByUrl(url);
    }
    getFileByUrl(url) {
        if (url.startsWith('/')) {
            url = url.substring(1);
        }
        return this.files.get(url);
    }
    isFragment(file) {
        return this.allFragments.indexOf(file.path) !== -1;
    }
    /**
     * A side-channel to add files to the resolver that did not come throgh the
     * stream transformation. This is for generated files, like
     * shared-bundle.html. This should probably be refactored so that the files
     * can be injected into the stream.
     */
    addFile(file) {
        logger.debug(`addFile: ${file.path}`);
        // Badly-behaved upstream transformers (looking at you gulp-html-minifier)
        // may use posix path separators on Windows.
        let filepath = path.normalize(file.path);
        // Store only root-relative paths, in URL/posix format
        this.files.set(path_transformers_1.urlFromPath(this.root, filepath), file);
    }
    /**
     * Attempts to retreive document-order transitive dependencies for `url`.
     */
    _getDependencies(url) {
        let dir = path.posix.dirname(url);
        return this.analyzer.metadataTree(url)
            .then((tree) => get_dependencies_from_document_1.getDependenciesFromDocument(tree, dir));
    }
    _addDependencies(filePath, deps) {
        // Make sure function is being called properly
        if (!this.allFragmentsToAnalyze.has(filePath)) {
            throw new Error(`Dependency analysis incorrectly called for ${filePath}`);
        }
        // Add dependencies to _dependencyAnalysis object, and push them through
        // the dependency stream.
        this._dependencyAnalysis.fragmentToFullDeps.set(filePath, deps);
        this._dependencyAnalysis.fragmentToDeps.set(filePath, deps.imports);
        deps.scripts.forEach((url) => this.pushDependency(url));
        deps.styles.forEach((url) => this.pushDependency(url));
        deps.imports.forEach((url) => {
            this.pushDependency(url);
            let entrypointList = this._dependencyAnalysis.depsToFragments.get(url);
            if (entrypointList) {
                entrypointList.push(filePath);
            }
            else {
                this._dependencyAnalysis.depsToFragments.set(url, [filePath]);
            }
        });
    }
    /**
     * Process the given dependency before pushing it through the stream.
     * Each dependency is only pushed through once to avoid duplicates.
     */
    pushDependency(dependencyUrl) {
        if (this.getFileByUrl(dependencyUrl)) {
            logger.debug('dependency has already been pushed, ignoring...', { dep: dependencyUrl });
            return;
        }
        let dependencyFilePath = path_transformers_1.pathFromUrl(this.root, dependencyUrl);
        if (minimatchAll(dependencyFilePath, this.sourceGlobs)) {
            logger.debug('dependency is a source file, ignoring...', { dep: dependencyUrl });
            return;
        }
        logger.debug('new dependency found, pushing into dependency stream...', dependencyFilePath);
        this._dependenciesStream.push(dependencyFilePath);
    }
}
exports.StreamAnalyzer = StreamAnalyzer;
class StreamResolver {
    constructor(analyzer) {
        this.deferredFiles = new Map();
        this.analyzer = analyzer;
        this.root = this.analyzer.root;
    }
    hasDeferredFile(filePath) {
        return this.deferredFiles.has(filePath);
    }
    hasDeferredFiles() {
        return this.deferredFiles.size > 0;
    }
    resolveDeferredFile(filePath, file) {
        let deferred = this.deferredFiles.get(filePath);
        deferred.resolve(file.contents.toString());
        this.deferredFiles.delete(filePath);
    }
    accept(url, deferred) {
        logger.debug(`accept: ${url}`);
        let urlObject = url_1.parse(url);
        // Resolve external files as empty strings. We filter these out later
        // in the analysis process to make sure they aren't included in the build.
        if (get_dependencies_from_document_1.isDependencyExternal(url)) {
            deferred.resolve('');
            return true;
        }
        let urlPath = decodeURIComponent(urlObject.pathname);
        let filePath = path_transformers_1.pathFromUrl(this.root, urlPath);
        let file = this.analyzer.getFile(filePath);
        if (file) {
            deferred.resolve(file.contents.toString());
        }
        else {
            this.deferredFiles.set(filePath, deferred);
            this.analyzer.pushDependency(urlPath);
        }
        return true;
    }
}
exports.StreamResolver = StreamResolver;
