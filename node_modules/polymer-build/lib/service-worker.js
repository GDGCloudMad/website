/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
"use strict";
const fs_1 = require('fs');
const path = require('path');
const logging = require('plylog');
const sw_precache_1 = require('sw-precache');
let logger = logging.getLogger('polymer-build.service-worker');
/**
 * Returns an array of file paths for the service worker to precache, based on
 * the information provided in the DepsIndex object.
 */
function getPrecachedAssets(depsIndex, project) {
    let precachedAssets = new Set(project.analyzer.allFragments);
    precachedAssets.add(project.entrypoint);
    for (let depImports of depsIndex.fragmentToFullDeps.values()) {
        depImports.imports.forEach((s) => precachedAssets.add(s));
        depImports.scripts.forEach((s) => precachedAssets.add(s));
        depImports.styles.forEach((s) => precachedAssets.add(s));
    }
    return Array.from(precachedAssets);
}
/**
 * Returns an array of file paths for the service worker to precache for a
 * BUNDLED build, based on the information provided in the DepsIndex object.
 */
function getBundledPrecachedAssets(project) {
    let precachedAssets = new Set(project.analyzer.allFragments);
    precachedAssets.add(project.entrypoint);
    precachedAssets.add(project.bundler.sharedBundleUrl);
    return Array.from(precachedAssets);
}
/**
 * Returns a promise that resolves with a generated service worker (the file
 * contents), based off of the options provided.
 */
function generateServiceWorker(options) {
    console.assert(!!options, '`project` & `buildRoot` options are required');
    console.assert(!!options.project, '`project` option is required');
    console.assert(!!options.buildRoot, '`buildRoot` option is required');
    options = Object.assign({}, options);
    let project = options.project;
    let buildRoot = options.buildRoot;
    let swConfig = Object.assign({}, options.swConfig);
    return project.analyzer.analyzeDependencies.then((depsIndex) => {
        let staticFileGlobs = Array.from(swConfig.staticFileGlobs || []);
        let precachedAssets = (options.bundled)
            ? getBundledPrecachedAssets(project)
            : getPrecachedAssets(depsIndex, project);
        staticFileGlobs = staticFileGlobs.concat(precachedAssets);
        staticFileGlobs = staticFileGlobs.map((filePath) => {
            if (filePath.startsWith(project.root)) {
                filePath = filePath.substring(project.root.length);
            }
            return path.join(buildRoot, filePath);
        });
        // swPrecache will determine the right urls by stripping buildRoot
        swConfig.stripPrefix = buildRoot;
        // static files will be pre-cached
        swConfig.staticFileGlobs = staticFileGlobs;
        // Log service-worker helpful output at the debug log level
        swConfig.logger = swConfig.logger || logger.debug;
        return new Promise((resolve, reject) => {
            logger.debug(`writing service worker...`, swConfig);
            sw_precache_1.generate(swConfig, (err, fileContents) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(new Buffer(fileContents));
                }
            });
        });
    });
}
exports.generateServiceWorker = generateServiceWorker;
/**
 * Returns a promise that resolves when a service worker has been generated
 * and written to the build directory. This uses generateServiceWorker() to
 * generate a service worker, which it then writes to the file system based on
 * the buildRoot & serviceWorkerPath (if provided) options.
 */
function addServiceWorker(options) {
    return generateServiceWorker(options).then((fileContents) => {
        return new Promise((resolve, reject) => {
            let serviceWorkerPath = path.join(options.buildRoot, options.serviceWorkerPath || 'service-worker.js');
            fs_1.writeFile(serviceWorkerPath, fileContents, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    });
}
exports.addServiceWorker = addServiceWorker;
